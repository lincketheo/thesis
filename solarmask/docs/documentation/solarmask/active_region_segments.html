<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>solarmask.active_region_segments API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>solarmask.active_region_segments</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .utils import *
from .data import *
from .active_region_parameters import ActiveRegionParameters

from skimage.morphology import square, binary_dilation
from skimage.measure import label
import numpy as np
import networkx as nx

from skimage.filters import threshold_local
from skimage.morphology import square
from skimage.measure import label
import matplotlib.pyplot as plt



class ActiveRegionSegments(ActiveRegionParameters):
    def __init__(self, Bz, Bx, By, cont, data_products = [&#34;baseline&#34;, &#34;graph&#34;, &#34;segmented&#34;]):
        super().__init__(Bz, Bx, By) 

        # All the data products the user wants to generate
        self.data_products = data_products
        self.cont = cont

        # The four &#34;segments&#34; as raw arrays (no nodes for graph)
        self.__baseline = np.ones(self.shape, dtype = bool)
        self.__background = None
        self.__umbra = None
        self.__penumbra = None
        self.__nl = None

        # The node number index is the index of the graph mask - I&#39;m seperating graph
        # and mask so that the masks aren&#39;t saved when I save the graph
        self.__node_masks = []
        self._G = nx.Graph()

        # Flags - to check and examine by eye?
        # If something weird happened - put true here
        self.__flags = {&#34;bordered_umbras&#34; : False}

    @property
    def nl_mask(self):
        &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
        finds neutral lines using the method described by Schrijver in
        
        **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


        Args:
            radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
            is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
            thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
        &#34;&#34;&#34;
        thresh = 150
        radius = 5
        if self.__nl is None:
            ######### SEGMENTED DATA SET ############
            if &#34;segmented&#34; in self.data_products:
                nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))
                self.__nl = nl_mask.copy()

            ######### GRAPH DATA SET ################
            if &#34;graph&#34; in self.data_products:
                labeled, labels, sizes = self.__group_pixels(nl_mask)
                labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 200)

                # Add all the graph nodes
                for i in labels:
                    mask = labeled == i
                    self.__add_node(mask, &#34;neutral line&#34;)

        return self.__nl

    @property
    def background_mask(self):
        &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
        Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
        &#34;&#34;&#34;
        if self.__background is None:
            if &#34;segmented&#34; in self.data_products:
                self.__background = ~(self.nl_mask | self.umbra_mask | self.penumbra_mask)
        return self.__background

    @property
    def umbra_mask(self):
        if self.__umbra is None:
            self.__assert_umbra_penumbra()
        return self.__umbra

    @property
    def penumbra_mask(self):
        if self.__penumbra is None:
            self.__assert_umbra_penumbra()
        return self.__penumbra

    @property
    def baseline_mask(self):
        return self.__baseline

    @property
    def node_masks(self):
        &#34;&#34;&#34;Getter for node masks

        Returns:
            np.array: A list of masks lining up to each of the node indexes / node names
        &#34;&#34;&#34;
        return self.__node_masks
    
    def __assert_umbra_penumbra(self):
        &#34;&#34;&#34;An original algorithm for detecting umbras and penumbras from a continuum image

        High Level Algorithm:

        1. bound continuum between 0 and 255

        2. use an adaptive filter on the bounded continuum

        3. group and label touching pixels 

        4. remove groups of pixels that are less than 500 from those remaining (if any) 

        5. remove groups of pixels that border the image (usually noise) from those remaining (if any) 

        6. remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)  

        7. remove take the largest 6 clusters from those remaining (if any) 

        8. The remaining groups are **penumbra outlines**, repeat the above process isolated only to the penumbra outlines
        if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras

        9. Keep the remaining 6 largest umbras
        &#34;&#34;&#34;
        if &#34;segmented&#34; in self.data_products:
            #We first segment large groups (that may be penumbras or umbras)
            cont_bounded = (255 * (self.cont - np.min(self.cont)) / np.ptp(self.cont)).astype(np.uint8)

            block_size = np.min(self.shape)
            if block_size % 2 == 0:
                block_size -= 1
                
            offset = 10
            binary_adaptive = cont_bounded &lt; (threshold_local(cont_bounded, block_size, offset = offset) - offset)

            ###### Filter Segmented ###########
            labeled_0, labels, sizes = self.__group_pixels(binary_adaptive)
            labels, sizes = self.__remove_bordering_pixels(labeled_0, labels, sizes)

            ###### UMBRA SEGMENTED MASK #############
            self.__umbra = (np.isin(labeled_0, labels))
            
            ###### Filter for graph #######
            labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 100)

            self.__penumbra = np.zeros(self.shape, dtype = bool)

            # For each large group - determine if this is a penumbra / umbra combo or just umbra
            for i in labels:
                mask = labeled_0 == i
                mx = np.max(self.cont[mask])
                mn = np.min(self.cont[mask])
                t = (mx - mn) / 2 + mn
                um = mask &amp; (self.cont &lt;= t)
                pu = mask &amp; (self.cont &gt; t)

                # Small group
                if np.count_nonzero(um) &lt; 50:
                    if &#34;graph&#34; in self.data_products:
                        self.__add_node(mask, &#34;umbra&#34;)

                # PENUMBRA AND UMBRA
                elif mx - mn &gt; 21000:
                    # Both umbra and penumbra
                    self.__umbra &amp;= ~pu
                    self.__penumbra |= pu

                    if &#34;graph&#34; in self.data_products:
                        # Further segment the umbra node again
                        labeled, labels, sizes = self.__group_pixels(pu)
                        labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 100)

                        for i in labels:
                            mask = labeled == i
                            self.__add_node(mask, &#34;penumbra&#34;)

                        # Further segment the umbra node again
                        labeled, labels, sizes = self.__group_pixels(um)
                        labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 50)

                        for i in labels:
                            mask = labeled == i
                            self.__add_node(mask, &#34;umbra&#34;)

                # ONLY UMBRA
                else:
                    if &#34;graph&#34; in self.data_products:
                        self.__add_node(mask, &#34;umbra&#34;)
            

    def __group_pixels(self, mask):
        &#34;&#34;&#34;Groups pixels in a binary mask based on if they are touching

        Args:
            mask (np.array): A mask with binary pixels

        Returns:
            labeled: a mask that is labeled from 0 to number of groups (0 is the background) the size of the number in the label doesn&#39;t mean anything
            labels: a list of labels in labeled
            sizes: a list of sizes corresponding to each element in labels
        &#34;&#34;&#34;
        labeled = label(mask, connectivity = 2)
        labels = np.unique(labeled)[1:]
        sizes = np.array([np.count_nonzero(labeled==i) for i in labels])
        return labeled, labels, sizes

    def __remove_small_groups(self, labeled: np.array, labels: np.array, sizes: np.array, p = 500):
        &#34;&#34;&#34;Removes groups of pixels smaller than p

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere((sizes &lt; p))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __remove_bordering_pixels(self, labeled: np.array, labels: np.array, sizes: np.array):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        bordered = []
        for i in range(len(labels)):
            rows, cols = np.where(labeled == labels[i])
            if min(rows) == 0 or min(cols) == 0:
                bordered.append(i)
                self.__flags[&#34;bordered_umbras&#34;] = True
            if max(cols) == self.shape[1] - 1 or max(rows) == self.shape[0] - 1:
                bordered.append(i)
                self.__flags[&#34;bordered_umbras&#34;] = True
        return np.delete(labels, bordered), np.delete(sizes, bordered)

    def __remove_percentage_max(self, labeled, labels, sizes, p = 0.01):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere(sizes &lt; p * np.max(sizes))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __largest_n_clusters(self, labels, sizes, n = 6):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        n = min(n, len(labels))
        a = np.partition(sizes, -n)[-n]
        return labels[sizes &gt;= a], sizes[sizes &gt;= a]

    def __add_node(self, mask, type):
        &#34;&#34;&#34;Adds a node to self graph and connects to all the previous nodes

        Args:
            data ([type]): [description]
            cur_node ([type]): [description]
            mask ([type]): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        cur_node = len(self.__node_masks)

        # Get the center of the node for plotting
        x, y = np.where(mask)
        x, y = int(np.mean(x)), int(np.mean(y))
        self._G.add_node(cur_node, pos = (y,x), type = type)

        mask_dil = binary_dilation(mask, square(3))

        for m in range(len(self.__node_masks)):
            shares_edge = np.count_nonzero(mask_dil &amp; self.__node_masks[m]) &gt; 0
            if shares_edge:
                self._G.add_edge(cur_node, m)

        self.__node_masks.append(mask_dil)


    def draw(self, axs):
        axs[0][0].imshow(self.cont, interpolation = &#34;none&#34;)
        axs[0][1].imshow(self.Bz, interpolation = &#34;none&#34;)
        axs[1][0].imshow(self.umbra_mask, interpolation = &#34;none&#34;)
        axs[1][1].imshow(self.penumbra_mask, interpolation = &#34;none&#34;)
        axs[2][0].imshow(self.nl_mask, interpolation = &#34;none&#34;)
        axs[2][1].imshow(self.background_mask, interpolation = &#34;none&#34;)

        color_keys = {&#34;penumbra&#34; : &#34;red&#34;, &#34;umbra&#34; : &#34;green&#34;, &#34;neutral line&#34; : &#34;blue&#34;}
        values = [color_keys.get(x[1][&#34;type&#34;]) for x in self._G.nodes.data()]
        pos = nx.get_node_attributes(self._G, &#34;pos&#34;)
        pos = {i : (pos[i][0], pos[i][1]) for i in pos}

        
        axs[3][0].imshow(self.cont, interpolation = &#34;none&#34;)
        axs[3][1].imshow(self.Bz, interpolation = &#34;none&#34;)
        nx.draw(self._G, pos, axs[3][0], node_size = 100, node_color = values, with_labels = False)
        nx.draw(self._G, pos, axs[3][1], node_size = 100, node_color = values, with_labels = False)

        for a in axs:
            for ax in a:
                ax.axis(False)
        

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="solarmask.active_region_segments.ActiveRegionSegments"><code class="flex name class">
<span>class <span class="ident">ActiveRegionSegments</span></span>
<span>(</span><span>Bz, Bx, By, cont, data_products=['baseline', 'graph', 'segmented'])</span>
</code></dt>
<dd>
<div class="desc"><p>A place to define physical parameters of an active region</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Bz</code></strong> :&ensp;<code>2d np.array</code></dt>
<dd>z component of magnetic field</dd>
<dt><strong><code>By</code></strong> :&ensp;<code>2d np.array</code></dt>
<dd>y component of magnetic field</dd>
<dt><strong><code>Bx</code></strong> :&ensp;<code>2d np.array</code></dt>
<dd>x component of magnetic field</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActiveRegionSegments(ActiveRegionParameters):
    def __init__(self, Bz, Bx, By, cont, data_products = [&#34;baseline&#34;, &#34;graph&#34;, &#34;segmented&#34;]):
        super().__init__(Bz, Bx, By) 

        # All the data products the user wants to generate
        self.data_products = data_products
        self.cont = cont

        # The four &#34;segments&#34; as raw arrays (no nodes for graph)
        self.__baseline = np.ones(self.shape, dtype = bool)
        self.__background = None
        self.__umbra = None
        self.__penumbra = None
        self.__nl = None

        # The node number index is the index of the graph mask - I&#39;m seperating graph
        # and mask so that the masks aren&#39;t saved when I save the graph
        self.__node_masks = []
        self._G = nx.Graph()

        # Flags - to check and examine by eye?
        # If something weird happened - put true here
        self.__flags = {&#34;bordered_umbras&#34; : False}

    @property
    def nl_mask(self):
        &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
        finds neutral lines using the method described by Schrijver in
        
        **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


        Args:
            radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
            is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
            thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
        &#34;&#34;&#34;
        thresh = 150
        radius = 5
        if self.__nl is None:
            ######### SEGMENTED DATA SET ############
            if &#34;segmented&#34; in self.data_products:
                nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))
                self.__nl = nl_mask.copy()

            ######### GRAPH DATA SET ################
            if &#34;graph&#34; in self.data_products:
                labeled, labels, sizes = self.__group_pixels(nl_mask)
                labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 200)

                # Add all the graph nodes
                for i in labels:
                    mask = labeled == i
                    self.__add_node(mask, &#34;neutral line&#34;)

        return self.__nl

    @property
    def background_mask(self):
        &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
        Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
        &#34;&#34;&#34;
        if self.__background is None:
            if &#34;segmented&#34; in self.data_products:
                self.__background = ~(self.nl_mask | self.umbra_mask | self.penumbra_mask)
        return self.__background

    @property
    def umbra_mask(self):
        if self.__umbra is None:
            self.__assert_umbra_penumbra()
        return self.__umbra

    @property
    def penumbra_mask(self):
        if self.__penumbra is None:
            self.__assert_umbra_penumbra()
        return self.__penumbra

    @property
    def baseline_mask(self):
        return self.__baseline

    @property
    def node_masks(self):
        &#34;&#34;&#34;Getter for node masks

        Returns:
            np.array: A list of masks lining up to each of the node indexes / node names
        &#34;&#34;&#34;
        return self.__node_masks
    
    def __assert_umbra_penumbra(self):
        &#34;&#34;&#34;An original algorithm for detecting umbras and penumbras from a continuum image

        High Level Algorithm:

        1. bound continuum between 0 and 255

        2. use an adaptive filter on the bounded continuum

        3. group and label touching pixels 

        4. remove groups of pixels that are less than 500 from those remaining (if any) 

        5. remove groups of pixels that border the image (usually noise) from those remaining (if any) 

        6. remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)  

        7. remove take the largest 6 clusters from those remaining (if any) 

        8. The remaining groups are **penumbra outlines**, repeat the above process isolated only to the penumbra outlines
        if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras

        9. Keep the remaining 6 largest umbras
        &#34;&#34;&#34;
        if &#34;segmented&#34; in self.data_products:
            #We first segment large groups (that may be penumbras or umbras)
            cont_bounded = (255 * (self.cont - np.min(self.cont)) / np.ptp(self.cont)).astype(np.uint8)

            block_size = np.min(self.shape)
            if block_size % 2 == 0:
                block_size -= 1
                
            offset = 10
            binary_adaptive = cont_bounded &lt; (threshold_local(cont_bounded, block_size, offset = offset) - offset)

            ###### Filter Segmented ###########
            labeled_0, labels, sizes = self.__group_pixels(binary_adaptive)
            labels, sizes = self.__remove_bordering_pixels(labeled_0, labels, sizes)

            ###### UMBRA SEGMENTED MASK #############
            self.__umbra = (np.isin(labeled_0, labels))
            
            ###### Filter for graph #######
            labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 100)

            self.__penumbra = np.zeros(self.shape, dtype = bool)

            # For each large group - determine if this is a penumbra / umbra combo or just umbra
            for i in labels:
                mask = labeled_0 == i
                mx = np.max(self.cont[mask])
                mn = np.min(self.cont[mask])
                t = (mx - mn) / 2 + mn
                um = mask &amp; (self.cont &lt;= t)
                pu = mask &amp; (self.cont &gt; t)

                # Small group
                if np.count_nonzero(um) &lt; 50:
                    if &#34;graph&#34; in self.data_products:
                        self.__add_node(mask, &#34;umbra&#34;)

                # PENUMBRA AND UMBRA
                elif mx - mn &gt; 21000:
                    # Both umbra and penumbra
                    self.__umbra &amp;= ~pu
                    self.__penumbra |= pu

                    if &#34;graph&#34; in self.data_products:
                        # Further segment the umbra node again
                        labeled, labels, sizes = self.__group_pixels(pu)
                        labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 100)

                        for i in labels:
                            mask = labeled == i
                            self.__add_node(mask, &#34;penumbra&#34;)

                        # Further segment the umbra node again
                        labeled, labels, sizes = self.__group_pixels(um)
                        labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes, 50)

                        for i in labels:
                            mask = labeled == i
                            self.__add_node(mask, &#34;umbra&#34;)

                # ONLY UMBRA
                else:
                    if &#34;graph&#34; in self.data_products:
                        self.__add_node(mask, &#34;umbra&#34;)
            

    def __group_pixels(self, mask):
        &#34;&#34;&#34;Groups pixels in a binary mask based on if they are touching

        Args:
            mask (np.array): A mask with binary pixels

        Returns:
            labeled: a mask that is labeled from 0 to number of groups (0 is the background) the size of the number in the label doesn&#39;t mean anything
            labels: a list of labels in labeled
            sizes: a list of sizes corresponding to each element in labels
        &#34;&#34;&#34;
        labeled = label(mask, connectivity = 2)
        labels = np.unique(labeled)[1:]
        sizes = np.array([np.count_nonzero(labeled==i) for i in labels])
        return labeled, labels, sizes

    def __remove_small_groups(self, labeled: np.array, labels: np.array, sizes: np.array, p = 500):
        &#34;&#34;&#34;Removes groups of pixels smaller than p

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere((sizes &lt; p))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __remove_bordering_pixels(self, labeled: np.array, labels: np.array, sizes: np.array):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        bordered = []
        for i in range(len(labels)):
            rows, cols = np.where(labeled == labels[i])
            if min(rows) == 0 or min(cols) == 0:
                bordered.append(i)
                self.__flags[&#34;bordered_umbras&#34;] = True
            if max(cols) == self.shape[1] - 1 or max(rows) == self.shape[0] - 1:
                bordered.append(i)
                self.__flags[&#34;bordered_umbras&#34;] = True
        return np.delete(labels, bordered), np.delete(sizes, bordered)

    def __remove_percentage_max(self, labeled, labels, sizes, p = 0.01):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere(sizes &lt; p * np.max(sizes))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __largest_n_clusters(self, labels, sizes, n = 6):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        n = min(n, len(labels))
        a = np.partition(sizes, -n)[-n]
        return labels[sizes &gt;= a], sizes[sizes &gt;= a]

    def __add_node(self, mask, type):
        &#34;&#34;&#34;Adds a node to self graph and connects to all the previous nodes

        Args:
            data ([type]): [description]
            cur_node ([type]): [description]
            mask ([type]): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        cur_node = len(self.__node_masks)

        # Get the center of the node for plotting
        x, y = np.where(mask)
        x, y = int(np.mean(x)), int(np.mean(y))
        self._G.add_node(cur_node, pos = (y,x), type = type)

        mask_dil = binary_dilation(mask, square(3))

        for m in range(len(self.__node_masks)):
            shares_edge = np.count_nonzero(mask_dil &amp; self.__node_masks[m]) &gt; 0
            if shares_edge:
                self._G.add_edge(cur_node, m)

        self.__node_masks.append(mask_dil)


    def draw(self, axs):
        axs[0][0].imshow(self.cont, interpolation = &#34;none&#34;)
        axs[0][1].imshow(self.Bz, interpolation = &#34;none&#34;)
        axs[1][0].imshow(self.umbra_mask, interpolation = &#34;none&#34;)
        axs[1][1].imshow(self.penumbra_mask, interpolation = &#34;none&#34;)
        axs[2][0].imshow(self.nl_mask, interpolation = &#34;none&#34;)
        axs[2][1].imshow(self.background_mask, interpolation = &#34;none&#34;)

        color_keys = {&#34;penumbra&#34; : &#34;red&#34;, &#34;umbra&#34; : &#34;green&#34;, &#34;neutral line&#34; : &#34;blue&#34;}
        values = [color_keys.get(x[1][&#34;type&#34;]) for x in self._G.nodes.data()]
        pos = nx.get_node_attributes(self._G, &#34;pos&#34;)
        pos = {i : (pos[i][0], pos[i][1]) for i in pos}

        
        axs[3][0].imshow(self.cont, interpolation = &#34;none&#34;)
        axs[3][1].imshow(self.Bz, interpolation = &#34;none&#34;)
        nx.draw(self._G, pos, axs[3][0], node_size = 100, node_color = values, with_labels = False)
        nx.draw(self._G, pos, axs[3][1], node_size = 100, node_color = values, with_labels = False)

        for a in axs:
            for ax in a:
                ax.axis(False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="solarmask.active_region_parameters.ActiveRegionParameters" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters">ActiveRegionParameters</a></li>
<li><a title="solarmask.active_region_derived_fields.ActiveRegionDerivedFields" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields">ActiveRegionDerivedFields</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="solarmask.active_region.ActiveRegion" href="active_region.html#solarmask.active_region.ActiveRegion">ActiveRegion</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.background_mask"><code class="name">var <span class="ident">background_mask</span></code></dt>
<dd>
<div class="desc"><p>Generates a background mask. If background is already generated, does nothing
Background is simply <span><span class="MathJax_Preview">\neg (Umbra \cup Penumbra \cup Neutral Line)</span><script type="math/tex; mode=display">\neg (Umbra \cup Penumbra \cup Neutral Line)</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def background_mask(self):
    &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
    Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
    &#34;&#34;&#34;
    if self.__background is None:
        if &#34;segmented&#34; in self.data_products:
            self.__background = ~(self.nl_mask | self.umbra_mask | self.penumbra_mask)
    return self.__background</code></pre>
</details>
</dd>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.baseline_mask"><code class="name">var <span class="ident">baseline_mask</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_mask(self):
    return self.__baseline</code></pre>
</details>
</dd>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.nl_mask"><code class="name">var <span class="ident">nl_mask</span></code></dt>
<dd>
<div class="desc"><p>Generates neutral lines using morphological operations and a flux threshold
finds neutral lines using the method described by Schrijver in</p>
<p><strong>C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. <em>The Astrophysical Journal, 655(2), 2007.</em></strong></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius</dd>
<dt>is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3</dt>
<dt><strong><code>thresh</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Flux threshold. Defaults to 150 (as used by Schjriver et. al).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nl_mask(self):
    &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
    finds neutral lines using the method described by Schrijver in
    
    **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


    Args:
        radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
        is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
        thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
    &#34;&#34;&#34;
    thresh = 150
    radius = 5
    if self.__nl is None:
        ######### SEGMENTED DATA SET ############
        if &#34;segmented&#34; in self.data_products:
            nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))
            self.__nl = nl_mask.copy()

        ######### GRAPH DATA SET ################
        if &#34;graph&#34; in self.data_products:
            labeled, labels, sizes = self.__group_pixels(nl_mask)
            labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 200)

            # Add all the graph nodes
            for i in labels:
                mask = labeled == i
                self.__add_node(mask, &#34;neutral line&#34;)

    return self.__nl</code></pre>
</details>
</dd>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.node_masks"><code class="name">var <span class="ident">node_masks</span></code></dt>
<dd>
<div class="desc"><p>Getter for node masks</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>A list of masks lining up to each of the node indexes / node names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node_masks(self):
    &#34;&#34;&#34;Getter for node masks

    Returns:
        np.array: A list of masks lining up to each of the node indexes / node names
    &#34;&#34;&#34;
    return self.__node_masks</code></pre>
</details>
</dd>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.penumbra_mask"><code class="name">var <span class="ident">penumbra_mask</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def penumbra_mask(self):
    if self.__penumbra is None:
        self.__assert_umbra_penumbra()
    return self.__penumbra</code></pre>
</details>
</dd>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.umbra_mask"><code class="name">var <span class="ident">umbra_mask</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def umbra_mask(self):
    if self.__umbra is None:
        self.__assert_umbra_penumbra()
    return self.__umbra</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="solarmask.active_region_segments.ActiveRegionSegments.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, axs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, axs):
    axs[0][0].imshow(self.cont, interpolation = &#34;none&#34;)
    axs[0][1].imshow(self.Bz, interpolation = &#34;none&#34;)
    axs[1][0].imshow(self.umbra_mask, interpolation = &#34;none&#34;)
    axs[1][1].imshow(self.penumbra_mask, interpolation = &#34;none&#34;)
    axs[2][0].imshow(self.nl_mask, interpolation = &#34;none&#34;)
    axs[2][1].imshow(self.background_mask, interpolation = &#34;none&#34;)

    color_keys = {&#34;penumbra&#34; : &#34;red&#34;, &#34;umbra&#34; : &#34;green&#34;, &#34;neutral line&#34; : &#34;blue&#34;}
    values = [color_keys.get(x[1][&#34;type&#34;]) for x in self._G.nodes.data()]
    pos = nx.get_node_attributes(self._G, &#34;pos&#34;)
    pos = {i : (pos[i][0], pos[i][1]) for i in pos}

    
    axs[3][0].imshow(self.cont, interpolation = &#34;none&#34;)
    axs[3][1].imshow(self.Bz, interpolation = &#34;none&#34;)
    nx.draw(self._G, pos, axs[3][0], node_size = 100, node_color = values, with_labels = False)
    nx.draw(self._G, pos, axs[3][1], node_size = 100, node_color = values, with_labels = False)

    for a in axs:
        for ax in a:
            ax.axis(False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="solarmask.active_region_parameters.ActiveRegionParameters" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters">ActiveRegionParameters</a></b></code>:
<ul class="hlist">
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.B" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.B">B</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Bh" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.Bh">Bh</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Bx" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.Bx">Bx</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.By" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.By">By</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Bz" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.Bz">Bz</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Bz_tot" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.Bz_tot">Bz_tot</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Bz_totabs" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.Bz_totabs">Bz_totabs</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.J" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.J">J</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.Jh" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.Jh">Jh</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.gamma" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.gamma">gamma</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_B_x" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_B_x">grad_B_x</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_B_y" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_B_y">grad_B_y</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bh_x" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bh_x">grad_Bh_x</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bh_y" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bh_y">grad_Bh_y</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bx_x" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bx_x">grad_Bx_x</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bx_y" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bx_y">grad_Bx_y</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_By_x" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_By_x">grad_By_x</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_By_y" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_By_y">grad_By_y</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bz_x" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bz_x">grad_Bz_x</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.grad_Bz_y" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.grad_Bz_y">grad_Bz_y</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.greenpot" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.greenpot">greenpot</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.hc" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.hc">hc</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.hctot" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.hctot">hctot</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.hctotabs" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.hctotabs">hctotabs</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.ihtot" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.ihtot">ihtot</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.ihtotabs" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.ihtotabs">ihtotabs</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.itot" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.itot">itot</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.itot_polarity" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.itot_polarity">itot_polarity</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.itotabs" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.itotabs">itotabs</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.norm" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.norm">norm</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.physical_features" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.physical_features">physical_features</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.rho" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.rho">rho</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.shear" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.shear">shear</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.totrho" href="active_region_parameters.html#solarmask.active_region_parameters.ActiveRegionParameters.totrho">totrho</a></code></li>
<li><code><a title="solarmask.active_region_parameters.ActiveRegionParameters.twist" href="active_region_derived_fields.html#solarmask.active_region_derived_fields.ActiveRegionDerivedFields.twist">twist</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="solarmask" href="index.html">solarmask</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="solarmask.active_region_segments.ActiveRegionSegments" href="#solarmask.active_region_segments.ActiveRegionSegments">ActiveRegionSegments</a></code></h4>
<ul class="two-column">
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.background_mask" href="#solarmask.active_region_segments.ActiveRegionSegments.background_mask">background_mask</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.baseline_mask" href="#solarmask.active_region_segments.ActiveRegionSegments.baseline_mask">baseline_mask</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.draw" href="#solarmask.active_region_segments.ActiveRegionSegments.draw">draw</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.nl_mask" href="#solarmask.active_region_segments.ActiveRegionSegments.nl_mask">nl_mask</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.node_masks" href="#solarmask.active_region_segments.ActiveRegionSegments.node_masks">node_masks</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.penumbra_mask" href="#solarmask.active_region_segments.ActiveRegionSegments.penumbra_mask">penumbra_mask</a></code></li>
<li><code><a title="solarmask.active_region_segments.ActiveRegionSegments.umbra_mask" href="#solarmask.active_region_segments.ActiveRegionSegments.umbra_mask">umbra_mask</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>